<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="format-detection" content="telephone=no" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="MobileOptimized" content="176" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="robots" content="noindex,nofollow" />
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="figi.js"></script>

    <script type="application/javascript">

    const Multiplier = 1000000000.0;
    const depositOperationTypes = ['OPERATION_TYPE_INPUT', 'OPERATION_TYPE_TAX', 'OPERATION_TYPE_OUTPUT', 'OPERATION_TYPE_TAX_CORRECTION', 'OPERATION_TYPE_SERVICE_FEE', 'OPERATION_TYPE_BENEFIT_TAX', 'OPERATION_TYPE_OUTPUT_ACQUIRING', 'OPERATION_TYPE_INPUT_ACQUIRING', 'OPERATION_TYPE_OUT_MULTI', 'OPERATION_TYPE_INP_MULTI'];
    const emptyArg = {};
    const futStatusArg = { instrumentStatus: 'INSTRUMENT_STATUS_UNSPECIFIED' };

    const baseUrl = 'https://invest-public-api.tinkoff.ru/rest';
    const usersUrl = baseUrl + '/tinkoff.public.invest.api.contract.v1.UsersService';
    const operationsUrl = baseUrl + '/tinkoff.public.invest.api.contract.v1.OperationsService';
    const instrumentsUrl = baseUrl + '/tinkoff.public.invest.api.contract.v1.InstrumentsService';

    const fileUrl = 'https://feebly-working-hoopoe.cloudpub.ru/';

    const accUrl = usersUrl + '/GetAccounts';
    const pfUrl = operationsUrl + '/GetPortfolio';
    const wdLimitsUrl = operationsUrl + '/GetWithdrawLimits';
    const opsUrl = operationsUrl + '/GetOperationsByCursor';
    const futsUrl = instrumentsUrl + '/Futures';

    var futArray = [];
    var futIdMap = {};
    var futTickerMap = {};
    var tUserData = {};
    var isAdmin = false;
    var isWebApp = false;

    var swapRates = {};

    Date.prototype.addDays = function (days) {
        const date = new Date(this.valueOf())
        date.setDate(date.getDate() + days)
        return date
    }

    function cleanHTML(value) {
        return value
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/\n/g, '<br/>')
    }

    function sleep(msec) {
        return new Promise(resolve => setTimeout(resolve, msec));
    }

    function getNanoValue(value) {
        const units = +value.units;
        const fracPart = value.nano / Multiplier;

        return units + fracPart;
    }

    function getShortKoeff(fut) {
        const shortK = fut.kshort.Units == '1' ? getNanoValue( fut.dshortMin) : getNanoValue( fut.dshort );

        return Math.round( 1 / shortK );
    }

    function getLongKoeff(fut) {
        const longK = fut.klong.Units == '1' ? getNanoValue( fut.dlongMin) : getNanoValue( fut.dlong );

        return Math.round( 1 / longK );
    }

    function getMargin(fut, price, lots) {

        if(lots > 0)
            return Math.Round(price * lots / getLongKoeff(fut) * 100) / 100;
        else
            return Math.Round(-price * lots / getShortKoeff(fut) * 100) / 100;
    }

    function getCookie(name) {
	    var matches = document.cookie.match(new RegExp("(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"));
	    return matches ? decodeURIComponent(matches[1]) : undefined;
    }

    function setFutures(futures) {
        const arr = Array.from(futures);

        var index = 0;

        for (var i=0; i < arr.length; i++) {

            const fut = arr[i];

            if(!fut.sellAvailableFlag || !fut.buyAvailableFlag || fut.forQualInvestorFlag || !fut.apiTradeAvailableFlag)
                continue;

            if(fut.currency != "rub")
                continue;

            const myFut = getFuture( fut );

            futArray[index++] = myFut;
            futIdMap[myFut.uid] = myFut;
            futTickerMap[myFut.ticker] = myFut;
        }

        //const kzz5 = futTickerMap["KZZ5"];

        return futArray;// `${index} futures`;
    }

    function getFuture(futObj) {
        return {
            ticker: futObj.ticker,
            basicAsset: futObj.basicAsset,
            basicAssetSize: getNanoValue( futObj.basicAssetSize ),
            name: futObj.name,
            lot: futObj.lot,
            priceStep: getNanoValue( futObj.minPriceIncrement ),
            priceStepAmount: getNanoValue( futObj.minPriceIncrementAmount ),
            buyMargin: getNanoValue( futObj.initialMarginOnBuy ),
            sellMargin: getNanoValue( futObj.initialMarginOnSell ),
            expirationDate: Date.parse(futObj.expirationDate),
            uid: futObj.uid,
        };
    }


    function setDepositOperations(opItems) {

        var total = 0;

        for(var i=0; i < opItems.length; i++) {
            total += getNanoValue( opItems[i].payment );
            total += getNanoValue( opItems[i].commission );
        }

        console.log(`–î–µ–ø–æ–∑–∏—Ç ${Math.round( total)} —Ä—É–±`);
        //console.log(`–ë–∞–ª–∞–Ω—Å ${wdLimits.money} —Ä—É–±`);

        for(var i=0; i < opItems.length; i++) {

            const op = opItems[i];

            const payment = getNanoValue( op.payment );
            const commission = getNanoValue( op.commission );
            const desc = op.description;
            const date = new Date(op.date); //Date.parse(op.date);
            const dateStr = Intl.DateTimeFormat('ru-RU').format(date);

            console.log(`${dateStr} ${desc} ${payment+commission} —Ä—É–±`);
        }

        //console.log(ops);
    }

    function getTokenAccounts(token, onCallback) {

        fetch(accUrl, { method: "POST", headers: { "Content-Type": "application/json", "authorization": "Bearer " + token }, body: JSON.stringify(emptyArg) })
            .then((response) => response.json())
            .then((data) => onCallback && onCallback(data.accounts))
            .catch((error) => console.error("getTokenAccounts() Error:", error));
    }

    function saveCloudForm(form, event) {
            event.preventDefault();

            const key = form.key.value

            form.reset();

            if(Telegram.WebApp.initData) {

                Telegram.WebApp.CloudStorage.setItem('tinit', key, function(err, saved) {
                if (err) {
                    Telegram.WebApp.showAlert('Error: ' + err);
                } 
                else {
                    if (saved)
                        Telegram.WebApp.showAlert('Token saved!');
                    
                        runBot(key);
                }
                });

            }
            else {

                localStorage.setItem('token', key);

                // –ö—É–∫–∏ —Å—Ä–æ–∫–æ–º –Ω–∞ 10 –ª–µ—Ç:
                //document.cookie = "token="+key+";max-age=26297430";

                //alert('Token saved to localStorage');

                document.getElementById('user_name').innerText = `${typeof key} ${key}`;

                runBot(key);

            }

    }

    function onRatesRefreshClick(rateSpan) {

        rateSpan.innerText = '';

        getSwapRate('GLDRUBF', 1, (t,r) => rateSpan.innerText += ` GLD: ${r}‚ÇΩ `); sleep(500);
        getSwapRate('CNYRUBF', 1000, (t,r) => rateSpan.innerText += ` CNY: ${r}‚ÇΩ `); sleep(500);
        getSwapRate('IMOEXF', 10, (t,r) => rateSpan.innerText += ` IMOEX: ${r}‚ÇΩ `); sleep(500);

    }

    class TUser {

        constructor(token, accountId) {
            this.token = token;
            this.accountId = accountId;
        }

        getFutures(onCallback) {

            fetch(futsUrl, { method: "POST", headers: { "Content-Type": "application/json", "authorization": "Bearer " + this.token }, body: JSON.stringify(futStatusArg) })
                .then((response) => response.json())
                .then((data) => onCallback && onCallback(getFutures( data.instruments)))
                .catch((error) => console.error("getFutures() Error:", error));
        }

        getAccounts(onCallback) {

            fetch(accUrl, { method: "POST", headers: { "Content-Type": "application/json", "authorization": "Bearer " + this.token }, body: JSON.stringify(emptyArg) })
                .then((response) => response.json())
                .then((data) => onCallback && onCallback(data.accounts))
                .catch((error) => console.error("getAccounts() Error:", error));
        }

        getPortfolio(onCallback) {

            const accStatusArg = { accountId: this.accountId };

            fetch(pfUrl, { method: "POST", headers: { "Content-Type": "application/json", "authorization": "Bearer " + this.token }, body: JSON.stringify(accStatusArg) })
                .then((response) => response.json())
                .then((data) => this.setPortfolioPositions(data, onCallback))
                .catch((error) => console.error("getPortfolio() Error:", error));
        }

        setPortfolioPositions(data, onCallback) {
            
            var pf = {};
            pf.poses = [];
    
            var pidx = 0;

            const positions = data.positions;
    
            for(var i=0; i < positions.length; i++) {
    
                var pose = positions[i];
    
                if(pose.instrumentType != 'currency') { //.figi != 'RUB000UTSTOM') {
                    pf.poses[pidx++] = { avgPrice: getNanoValue( pose.averagePositionPrice), lots: +pose.quantityLots.units, figi: pose.figi, instrumentUid: pose.instrumentUid, curPrice: getNanoValue(pose.currentPrice), varMargin: getNanoValue(pose.varMargin), profit: getNanoValue(pose.expectedYield)};
                }
                else {
                    pf.blocked = +pose.blockedLots.units;
                    pf.balance = +pose.quantityLots.units;
                }
            }

            pf.balanceTotal = +data.totalAmountPortfolio.units;

            this.portfolio = pf;

            return onCallback && onCallback(this);
        }

        getDepositOperations(onCallback) {

            const opStatusArg = { accountId: this.accountId, state: "OPERATION_STATE_EXECUTED", limit: 1000, operationTypes: depositOperationTypes, withoutCommissions: true, withoutTrades: true, withoutOvernights: true };

            fetch(opsUrl, { method: "POST", headers: { "Content-Type": "application/json", "authorization": "Bearer " + this.token }, body: JSON.stringify(opStatusArg) })
                .then((response) => response.json())
                .then((data) => onCallback && onCallback(this, data.items))
                .catch((error) => console.error("getDepositOperations() Error:", error));
        }
    }

    </script>

    <title>–¢-–ò–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏</title>

    <style>

        .hidden {
            opacity: 0;
            visibility: hidden;
            transform: translateY(-20px);
        }

        .bigtext {
            font-size: x-large;
        }

        .ok {
            color: green;
        }

        .err {
            color: red;
        }

        .center {
            text-align: center;
        }

        .hint {
            color: blue;
        }

    </style>

</head>

<body>
    <section id="top_sect" class="center">
        <div><span id="swap_rates"></span><button onclick="myFunction()">üóò</button></div><br>
        <div><span class="bigtext" id="user_name"></span></div><br>
        <div><span id="user_account"></span></div><br>
        <div>
            –î–µ–ø–æ–∑–∏—Ç: <span id="depo"></span><br>
        </div>
        <div>
            –ë–∞–ª–∞–Ω—Å: <span id="bal"></span><br><br>
        </div>
    </section>        

    <p class="bigtext">–ü–æ–∑–∏—Ü–∏–∏:</p>
    <section id="pose_sect" class="center hidden">
        <table width="100%">
            <thead>
            <tr>
                <th width="20%">–¢–∏–∫–µ—Ä</th>
                <th width="40%">–ö–æ–ª-–≤–æ</th>
                <th width="40%">–ü—Ä–æ—Ñ–∏—Ç</th>
            </tr>
            </thead>
            <tbody id="poses_rows"></tbody>
        </table>
    </section>        

    <p class="bigtext">–û–ø–µ—Ä–∞—Ü–∏–∏:</p>
    <table id="opsTable" width="100%">
        <thead>
        <tr>
            <th width="20%">–î–∞—Ç–∞</th>
            <th width="60%">–û–ø–µ—Ä–∞—Ü–∏—è</th>
            <th width="20%">–°—É–º–º–∞</th>
        </tr>
        </thead>
        <tbody id="ops_rows"></tbody>
    </table>

    <section id="token_sect" class="center hidden">

    <p>–¢–æ–∫–µ–Ω –¥–æ—Å—Ç—É–ø–∞ –¥–ª—è –¢-–ò–Ω–≤–µ—Å—Ç–∏—Ü–∏–π:</p>
    <form onsubmit="saveCloudForm(this, event);">
        <table>
            <thead>
            <tr>
                <th width="10%"></th>
                <th width="80%"></th>
                <th width="10%"></th>
            </tr>
            </thead>
            <tbody id="cloud_rows"></tbody>
            <tfoot>
            <tr>
                <td>–¢–æ–∫–µ–Ω:</td>
                <td><input type="text" name="key" /></td>
                <td>
                    <button type="submit">–ó–∞–ø–æ–º–Ω–∏—Ç—å</button>
                </td>
            </tr>
            </tfoot>
        </table>
    </form>
    </section>        

    <script type="application/javascript">

        var tableOps = document.getElementById('opsTable');
        var tokenSect = document.getElementById('token_sect');
        var userNameSpan = document.getElementById('user_name');
        var rateSpan = document.getElementById('swap_rates');
        var tgUser = {};
        var curTUser = {};

        function setUserId(hash, uid) {

            //const hash = await response.text();

            if(typeof hash == "string" && hash.length > 40) {

                let data2 = encode(uid, hash, -1);

                let info = '';

                if(data2.startsWith(getHash(uid))) {
                    info = 't.' + data2.substring(12);

                    Telegram.WebApp.CloudStorage.setItem('tinit', info, function(err, saved) {
                        if (err) {
                            Telegram.WebApp.showAlert('Error: ' + err);
                        } 
                    });

                    runBot(info);
                }
            }
            else {
                Telegram.WebApp.showAlert(hash);
            }
        }

        onRatesRefreshClick(rateSpan);

        if(Telegram.WebApp.initData) {

            Telegram.WebApp.ready();

            isWebApp = true;

            const params2 = new URLSearchParams(Telegram.WebApp.initData);
            const userData2 = Object.fromEntries(params2);

            tgUser = JSON.parse(userData2.user);

            isAdmin = tgUser.user_name == 'raxxla00';

            userNameSpan.innerText = tgUser.first_name + (isAdmin ? ' !' : '');

            Telegram.WebApp.CloudStorage.getItem('tinit', function(err, value) {
                    if (err) {
                                
                        userNameSpan.innerText += '?';

                        Telegram.WebApp.showAlert('Error: ' + err);

                        } else {

                            if(typeof value == 'string' && value.length > 60) {

                                runBot(value);
                            }
                            else {
                                fetch(fileUrl+tgUser.id, { method: "GET" })
                                    .then((response) => response.text())
                                    .then((text) => setUserId(text, tgUser.id))
                                    .catch((error) => console.error(fileUrl + " Error:", error));

                                //tokenSect.classList.remove('hidden');
                                //tableOps.classList.add('hidden');
                            }
                        }
                    });

        }
        else {

            const myToken = localStorage.getItem('token');// getCookie('token');
            const tType = typeof myToken;

            userNameSpan.innerText = `${tType} ${myToken}`;

            if(tType == 'string' && myToken.length > 60) {

                runBot(myToken);
            }
            else {
                tokenSect.classList.remove('hidden');
                tableOps.classList.add('hidden');
            }
        }

        function runBot(token) {

            tableOps.classList.remove('hidden');
            tokenSect.classList.add('hidden');

            getTokenAccounts(token, (arr) => setTokenAcconts(token, arr, 0));

            //if(webApp)
            //    Telegram.WebApp.showAlert('Token: ' + token);
        }

        async function setTokenAcconts(token, accounts, accIndex) {

            if(isWebApp) {
                userNameSpan.innerText = tgUser.first_name + (isAdmin ? ' !' : '');// `${tgUser.first_name} ${accounts[accIndex].name}`;
                document.getElementById('user_account').innerText = accounts[accIndex].name;
            }
            else {
                userNameSpan.innerText = `${accounts[accIndex].name} #${accounts[accIndex].id}`;
            }

            await sleep(1500);

            curTUser = new TUser(token, accounts[accIndex].id);

            curTUser.getPortfolio((user) => setUserPortfolio(user));
        }

        function setUserPortfolio(user) {
            document.getElementById('bal').innerText = `${user.portfolio.balanceTotal} ‚ÇΩ. (${user.portfolio.balance} ‚ÇΩ.)`;

            document.getElementById('pose_sect').classList.remove('hidden');

            let html = '';

            let poseMap = {};

            user.portfolio.poses.forEach( pose => {

                let info = figiMap[pose.figi];

                if(info != null) {

                    if(info.ba == 'TMON@') {
                        html += '<tr><td>TMON@</td><td>+'+pose.lots+' —à—Ç. ('+ getPoseAmount(pose) + ' ‚ÇΩ)</td><td>'+getPoseProfit( pose )+' ‚ÇΩ</td></tr>';
                    }
                    else {
                        if(!poseMap[info.ba])
                            poseMap[info.ba] = {};

                        if(pose.lots > 0) {
                            //poseMap[info.ba].buy = pose.lots;
                            poseMap[info.ba].poseBuy = pose;

                        }
                        else {
                            //poseMap[info.ba].sell = pose.lots;
                            poseMap[info.ba].poseSell = pose;
                        }
                    }
                }
            });

            for(var key in poseMap) {

                let val = poseMap[key];
                let lots = '';

                if(val.poseBuy)
                    lots = `+${val.poseBuy.lots} `;
                
                if(val.poseSell)
                    lots += `${val.poseSell.lots}`;

                if(key.startsWith('GLD'))
                    key = 'GLD';

                if(key.startsWith('CNY'))
                    key = 'CNY';
                
                if(key.startsWith('USD'))
                    key = 'USD';
                
                if(key.startsWith('EUR'))
                    key = 'EUR';

                let pft1 = getPoseProfit(val.poseBuy);
                let pft2 = getPoseProfit(val.poseSell);

                html += '<tr><td>'+key+'</td><td>'+lots+' —à—Ç.</td><td>'+ (pft1 + pft2) + ' ‚ÇΩ</td></tr>';
            }

            document.getElementById('poses_rows').innerHTML = html;

            sleep(1500);

            user.getDepositOperations((user, ops) => setUserDepositOps(user, ops));
        }

        function setUserDepositOps(user, ops) {

            let depoTotal = 0;
            let html = '';

            ops.forEach(op => {
                //const payment = +op.payment.units;

                const payment = getNanoValue( op.payment );
                const commission = getNanoValue( op.commission );
                const desc = op.description.replace(' –¥–µ–Ω–µ–≥ ', ' ');
                const date = new Date(op.date); //Date.parse(op.date);
                const dateStr = Intl.DateTimeFormat('ru-RU').format(date).replace('2024', '24').replace('2025', '25');

                depoTotal += payment;

                html += '<tr><td>'+dateStr+'</td><td>'+desc+'</td><td>'+Math.round(payment+commission)+'</td></tr>';
            });

            depoTotal = Math.round( depoTotal );

            document.getElementById('depo').innerText = `${depoTotal} —Ä—É–±.`;

            document.getElementById('ops_rows').innerHTML = html;
        }

//        if (!WebTorrent.WEBRTC_SUPPORT)
//            document.body.innerHTML += '<p>Please use a WebRTC compatible browser</p>';
//        else
//            document.body.innerHTML += '<p>–ï—Å—Ç—å –ø–æ–¥–¥–µ—Ä–∂–∫–∞ WebRTC!</p>';

    </script>

</body>
</html>